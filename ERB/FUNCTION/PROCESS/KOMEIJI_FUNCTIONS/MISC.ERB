;-------------------------------------------------
;잡다한 함수 두는 곳(미정리)
;-------------------------------------------------
;과거에 누군가씨가 몰래 만들고 있던 이상한 패치(?)(이)나 미완성의구상(?)등에서,
;비교적 사용할 수 있을 것 같지만 분류를 잘 모르는 함수를 뽑아내 모은 파일
;완전하게 합법인 것으로 안심 주세요
;생각보다는 심플한 함수… 일까?
;그 중 정리된다고 생각하기 때문에 배치나 처리 따위 바뀔지도 모릅니다@revkoishi(14/05/19)
;-------------------------------------------------
;함수의 개요
;·INPUT_RANGE(|D)… 지정 범위내인가 어떤가의 체크를 실시하는 수치 입력 함수
;·TINPUT_RANGE(|D)… 시간제한포함의 INPUT_RANGE
;·NOBYNAME…NAME 또는 CALLNAME로부터 NO를취득 하는 식 안의 함수
;·SIGN(S|V)… 인수 0의 수치의 부호에 근거해, 인수 1～3중에서 1개을반환식 안의 함수
;·SRL… 논리 오른쪽 쉬프트 연산했다결과을반환식 안의 함수
;-------------------------------------------------

;-------------------------------------------------
;함수명:INPUT_RANGE(|D)
;개  요점:지정 범위 수치 입력 함수
;인  수:ARG:0…[생략가능] 입력을 허가하는 하한치. 생략했다경우는 0
;　　　 ARG:1…[생략가능] 입력을 허가하는 상한치. 생략했다경우는 1
;　　　 ARG:2…[생략가능] 인수의 대소에 응해 하한치·상한치를 설정할지 어떨지(진위치). 생략했다경우는 가짜(0, 하지 않는다)
;　　　　　　　　　　　 진( 0이외)에했다경우는, ARG:0으로 ARG:1을 비교해 작은 편을 하한·큰 편을 상한으로 합니다
;반환값:유저의 입력했다수치(ARG:0～ARG:1의 사이)
;기본적으로 DO-LOOP내에서 INPUT했다결과를 INRANGE로 체크하고 있을 뿐입니다
;별로 INPUTINT 사용해도 좋습니다만 모처럼인 것으로
;특히 비틂이 없는 메뉴라든지는돌아가기를-1으로 해 두면 이것으로 충분하기도 하고
;D옵션으로 입력시 따위의 문자색을 디폴트색으로 표시할 수 있습니다. 주로구상전용
;-------------------------------------------------
@INPUT_RANGE(ARG:0 = 0, ARG:1 = 1, ARG:2 = 0)
#LOCALSIZE 2
SIF ARG:2 && ARG:0 > ARG:1
	SWAP ARG:0, ARG:1
SIF ARG:0 > ARG:1
	THROW @INPUT_RANGE로 예외가 발생. 무효인 허용 범위입니다（{ARG:0}～{ARG:1}）  ※ARG:2（{ARG:2}）를 실로 하는 것으로도 회피할 수 있습니다
LOCAL:1 = CURRENTREDRAW()
REDRAW 0
DO
	INPUT
	LOCAL:0 = !INRANGE(RESULT, ARG:0, ARG:1)	;입력 체크:범위외
	IF LOCAL:0
		CLEARLINE 1
		REUSELASTLINE 입력치가 범위외입니다
	ENDIF
LOOP LOCAL:0
REDRAW LOCAL:1
RETURN RESULT

@INPUT_RANGED(ARG:0 = 0, ARG:1 = 1)
#LOCALSIZE 1
LOCAL:0 = GETCOLOR()
RESETCOLOR
CALL INPUT_RANGE(ARG:0, ARG:1)
SETCOLOR LOCAL:0
RETURN RESULT


;-------------------------------------------------
;함수명:TINPUT_RANGE(|D)
;개  요점:시간제한 다하고 지정 범위 수치 입력 함수
;인  수:ARG:0…[생략가능] 입력을 허가하는 하한치. 생략했다경우는 0
;　　　 ARG:1…[생략가능] 입력을 허가하는 상한치. 생략했다경우는 1
;　　　 ARG:2…[생략가능] 인수의 대소에 응해 하한치·상한치를 설정할지 어떨지(진위치). 생략했다경우는 가짜(0, 하지 않는다)
;　　　　　　　　　　　 진( 0이외)에했다경우는, ARG:0으로 ARG:1을 비교해 작은 편을 하한·큰 편을 상한으로 합니다
;　　　 ARG:3…[생략가능] 제한시간(밀리 세컨드). 100 밀리 세컨드 단위보다 세세한 값을 설정해도 정확한 동작은 할 수 없기 때문에 주의. 생략했다경우는 10, 000 밀리 세컨드
;　　　 ARG:4…[생략가능] 시간조각시의 반환값. 생략했다경우는 __INT_MIN__
;　　　 ARG:5…[생략가능] 나머지시간표시(진위치). 진( 0이외)의 경우는 남아시간표시를 실시합니다. 생략했다경우는 진(표시한다)
;반환값:유저의 입력했다수치(ARG:0～ARG:1의 사이), 혹은시간조각시의 반환값
;INPUT_RANGE의시간제한부판. TINPUTINT와는 인수순서나 생략시의 거동 따위가 다르거나
;에서도 무엇에 사용하는지는 잘 모른다（
;D옵션으로 입력시 따위의 문자색을 디폴트색으로 표시할 수 있습니다. 주로구상전용
;-------------------------------------------------
@TINPUT_RANGE(ARG:0 = 0, ARG:1 = 1, ARG:2 = 0, ARG:3 = 10000, ARG:4 = __INT_MIN__, ARG:5 = 1)
#LOCALSIZE 5
SIF ARG:2 && ARG:0 > ARG:1
	SWAP ARG:0, ARG:1
SIF ARG:0 > ARG:1
	THROW @TINPUT_RANGE로 예외가 발생. 무효인 허용 범위입니다（{ARG:0}～{ARG:1}）  ※ARG:2（{ARG:2}）를 실로 하는 것으로도 회피할 수 있습니다
LOCAL:2 = LINECOUNT
LOCAL:3 = CURRENTREDRAW()	;REDRAW 0으로 들어 오면 나머지시간표시가 움직이지 않기 때문에 이 가드는 중요
LOCAL:4 = 0					;재입력플래그
REDRAW ARG:5 != 0
DO
	LOCAL:1 = GETMILLISECOND()
	TINPUT ARG:3, ARG:4, ARG:5
	ARG:3 -= GETMILLISECOND() - LOCAL:1
	IF ARG:3 > 0
		LOCAL:0 = !INRANGE(RESULT, ARG:0, ARG:1)
		IF LOCAL:0
			CLEARLINE LINECOUNT - LOCAL:2
;OriginalString : 入力値が範囲外です
			PRINTL 입력치가 범위외입니다
		ENDIF
		LOCAL:4 = 1
	ELSE
		LOCAL:0 = 0
		;※잠정 처리. ISTIMEOUT 변수가 수정당했다 후, 정식 대응할지도(하지 않아도 괜찮을지도)
		;입력 후시간 끊어지고 한편 입력치 범위외의 경우는시간조각 날조
		IF HTML_TOPLAINTEXT(HTML_GETPRINTEDSTR(2)) != "시간 잘라라" && !INRANGE(RESULT, ARG:0, ARG:1)
			RESULT = ARG:4
			CLEARLINE LINECOUNT - LOCAL:2
;OriginalString : \@ LOCAL:4 ? 入力値が範囲外です\n # \@시간切れ\n{RESULT}
			PRINTFORML \@ LOCAL:4 ? 입력치가 범위외입니다\n # \@마감 시간\n{RESULT}
		ENDIF
		;입력 후시간 끊어지고 한편 입력치 범위내의 경우는시간내에 올바르게 입력 되어있으므로 스르
		;입력중시간조각의 경우는 TINPUT로시간조각 처리 행해지고 있으므로 스르
	ENDIF
LOOP LOCAL:0
REDRAW LOCAL:3
RETURN RESULT

@TINPUT_RANGED(ARG:0 = 0, ARG:1 = 1, ARG:2 = 0, ARG:3 = 10000, ARG:4 = __INT_MIN__, ARG:5 = 1)
#LOCALSIZE 1
LOCAL:0 = GETCOLOR()
RESETCOLOR
CALL TINPUT_RANGE(ARG:0, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5)
SETCOLOR LOCAL:0
RETURN RESULT


;-------------------------------------------------
;함수명:NOBYNAME
;개  요점:캐릭터명→캐릭터번호변환 함수
;인  수:ARGS:0… 캐릭터의 이름(NAME) 또는 통칭(CALLNAME)
;반환값:지정했다캐릭터의 캐릭터번호(NO)
;비  고:식 안의 함수
;하나 하나전캐릭터의 NO라든지 기억하지 않을 것이고, 때 마다 조사하는 것도 귀찮을 것이고…
;실은 NO상당한 수치 캐릭터 라인에서도 통과하지만 특수용도인 것으로 헤아려 주세요
;기능적으로 제외할까 헤매었지만, 다른 함수내에서 사용하는 분에는 편리한가라고 생각해…
;캐릭터 라인교? 그런데, 무슨 일입니까(시치미떼고)
;-------------------------------------------------
@NOBYNAME(ARGS:0)
#FUNCTION
#LOCALSIZE 1
LOCAL:0 = ISNUMERIC(ARGS:0) ? TOINT(ARGS:0) # GETNUM(RELATION, ARGS:0)
SIF !EXISTCSV(LOCAL:0)
	THROW @NOBYNAME로 예외가 발생 섬했다. 존재하지 않는 캐릭터명 혹은 캐릭터번호입니다（%ARGS:0%）
RETURNF LOCAL:0


;-------------------------------------------------
;함수명:SIGNS
;개  요점:수치의 부호로 3 분기시킨다함수(캐릭터 라인판)
;인  수:ARG:0… 분기의 조건이 되는 수치
;　　　 ARGS:0…ARG:0이 마이나스였던 때의 반환값
;　　　 ARGS:1…ARG:0이±0이었던 때의 반환값
;　　　 ARGS:2…ARG:0이 플러스였던 때의 반환값
;반환값:ARG:0에 근거해, ARGS:0~2의 언젠가
;비  고:식 안의 함수
;가끔 3항연산자라면손가발리나구라고, 이런 것을 갖고 싶어지는 것 같은… 생각이 든다
;당연합니다만 합선 평가하지 않으므로, 캐릭터 변수 따위를 도했다 있고 경우에는 주의를
;겉모습 조건 분기 하고 있지 않는데 분명하게 분기 하는 것이 우리(?)
;<=>나─±＋를 도했다하면 장소에 따라서는 심플하게 쓸 수 있을지도
;라고 해도 같은 패턴을 빈번하게 이용한다면 별도 함수화했다 (분)편이 빠르다고는 생각하지만
;-------------------------------------------------
@SIGNS(ARG:0, ARGS:0, ARGS:1, ARGS:2)
#FUNCTIONS
RETURNF ARGS:(SIGN(ARG:0) + 1)


;-------------------------------------------------
;함수명:SIGNV
;개  요점:수치의 부호로 3 분기시킨다함수(수치판)
;인  수:ARG:0… 분기의 조건이 되는 수치
;　　　 ARG:1…ARG:0이 마이나스였던 때의 반환값
;　　　 ARG:2…ARG:0이±0이었던 때의 반환값
;　　　 ARG:3…ARG:0이 플러스였던 때의 반환값
;반환값:ARG:0에 근거해, ARG:1~3의 언젠가
;비  고:식 안의 함수
;SIGNS와 하고 있는 것은 똑같습니다. S나 V의 의미는 PRINTS나 PRINTV와 함께
;함수명은 SIGN_STR나 SIGN_INT에했다 (분)편이 알기 쉬워서는이라고도 생각했지만,
;이손의 함수는 이름이 짧은 것이 잘 처리하기 쉬운 기분이했다의 것으로…
;-------------------------------------------------
@SIGNV(ARG:0, ARG:1, ARG:2, ARG:3)
#FUNCTION
RETURNF ARG:(SIGN(ARG:0) + 2)


;-------------------------------------------------
;함수명:SRL
;개  요점:논리 오른쪽 쉬프트 함수
;인  수:ARG:0… 쉬프트대상의 비트열
;　　　:ARG:1… 쉬프트 카운트
;반환값:논리 오른쪽 쉬프트 연산 결과
;비  고:식 안의 함수
;논리 오른쪽 쉬프트 연산 같은 계산을 실시한다(모언어의>>>연산자 같은 분위기)
;부호 비트의상태에 관련되지 않고, 빈 비트에 0이 들어간다
;함수명은 ShiftRightLogical보다. 이제 와서는 그다지 사용하지 않는 감
;-------------------------------------------------
@SRL(ARG:0, ARG:1)
#FUNCTION
ARG:1 &= 0x3F	;만약을 위해 하위 6 bit를 꺼내 쉬프트 카운트로 한다(0～63). Emuera의 움직임(C#의 움직임)에 맞춘 생각
;쉬프트 카운트가 0이 아니면, 논리 오른쪽 쉬프트나무를 해 돌려준다. 0이라면, ARG:0을 그대로 돌려준다
RETURNF ARG:1 ? (ARG:0 >> ARG:1) & (0x7FFFFFFFFFFFFFFF >> ARG:1 - 1) # ARG:0
